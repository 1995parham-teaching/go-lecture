Introduction to Go
Amirkabir University of Technology Linux Festival
28 May 2016


Parham Alvani
parham.alvani@gmail.com
http://1995parham.me/

* The Go programming language

- Modern
- Compact, concise, general-purpose
- Imperative, statically type-checked, dynamically type-safe
- Garbage-collected
- Opinionated, no warnings, unused local vars and imports are an error
- Strong support for concurrency
- Compiles to native code, statically linked
- Fast compilation, efficient execution
- UTF8

Designed by programmers for programmers!

* The Go programming language

.image img/gopher.png
.caption gopher :D

* GoLang Concepts

* Outline

- The Go programming language
- Hello, World!
- Statements
- The GoLang concepts [Values]
- Prime, or Not Prime
- The GoLang concepts [Functions]
- The GoLang concepts [Structures]
- The GoLang concepts [Interfaces]
- The GoLang concepts [Casting Types]
- Analytic geometry !
- Slices and Arrays

* Hello, World!

.play src/hello.go

- Package Statements
- Imported Packages
- ....

* Constants

- Maintained precisely:
	const e = 2.71828182845904523536028747135266249775724709369995957496696763
	const third = 1/3
- Typed or without type:
	const M64 int64 = 1<<20
        const M = 1<<20
- Evaluated at compile-time:
	const big = 1<<100 / 1e30  // valid constant expression

Compiler complains if a constant doesn't fit where it is _used_.

.link http://blog.golang.org/constants

* Variables

- Statically typed:
	var x int
	var s, t string
- Implicitly or explicitly initialized:
	var x int
	var s, t string = "foo", "bar"  // multiple assignment

	var x = 42                      // int
	var s, b = "foo", true          // string, bool
- Short variable declaration (inside functions only):
	x := 42
	s, b := "foo", true
- Can safely take address of _any_ variable!
	return &x
# compiler will do the right thing

* Statements

- Curly braces (C style)
- Multiple assignments and some other new constructs
- Statements are _not_ Expressions.
- Many cleanups: mandatory braces, no parentheses for conditionals, implicit break in switches, no semicolons, etc.

* Statements, continued

	a, b = b, a                 // swap
	f, err = os.Open(filename)

	if x < y {
		return x
	} else {
		return y
	}

	switch day {
	case Mon:
		...
		// break is implicit
	case Tue, Wed:
		...
	}

* Statements, continued

- Unified `for` syntax

	for {
		// loop forever
	}

`range` over arrays, slices, and maps

	for i, num := range numbers { ... }
	for city, pop := range population { ... }

Not shown: break, goto, continue, fallthrough

* The GoLang concepts [Values]

.play src/values.go
The `new()` built-in function creates a new integer and returns a pointer to it.

* Prime, or Not Prime
.play src/prime.go

* The GoLang concepts [Functions]
.play src/functions.go

* The GoLang concepts [Structures]
.play src/structures.go
- C Structures :D
- Data hiding
- `S1`, `S2`, `S3` are public and can be accessed from anywhere.
- `private` is private and is only visible to code in the same package.

* The GoLang concepts [Methods]
.play src/methods.go

* The GoLang concepts [Interfaces]
.code src/interfaces.go

* The GoLang concepts [Casting Types]
- type conversion: A type conversion is similar to a cast in C. It reinterprets the value as a new type
.code src/type-conversion.go

* The GoLang concepts [Casting Types]
- type assertion: They do not convert between types; they simply state to the compiler that the underlying value has the specific type.
.play src/type-assertion.go

* Analytic geometry !
Let's write some code
- Create Point Interface
- Create CatesianPoint Structure
- Create PolarPoint Structure

* Analytic geometry !
- Create Point Interface

* Analytic geometry !
- Create CatesianPoint Structure

* Analytic geometry !
- Create PolarPoint Structure

* Slices and Array
- Arrays
.play src/arrays.go

* Slices and Array
- Slices

	[]T  // slice of T

- Descriptor for an underlying array segment
- May grow and shrink
- Has length and capacity
- Assigning a slice copies the descriptor, not the underlying array

Common slice operations:

	len(s)
	s[i]
	s[i:j]
	append(s, x)  // append element x to slice s and return new slice

- Slices play the role of dynamically sized arrays
- Widely used in Go code

* Concurrency

* Outline

- Goroutines
- Communication via channels

* Goroutines

- The _go_ statement launches a function call as a goroutine
	go f()
	go f(x, y, ...)

- A goroutine runs concurrently (but not necessarily in parallel)
- A goroutine is a thread of control within the program, with its own local variables and stack. Much cheaper to create and schedule than operating system threads.


* A simple example

.code src/concurrency1.go /f START/,/f END/

Function f is launched as 3 different goroutines, all running concurrently:

.play src/concurrency1.go /main START/,/main END/


* Communication via channels

A channel type specifies a channel value type (and possibly a communication direction):

	chan int
	chan<- string  // send-only channel
	<-chan T       // receive-only channel

A channel is a variable of channel type:

	var ch chan int
	ch := make(chan int)  // declare and initialize with newly made channel

A channel permits _sending_ and _receiving_ values:

	ch <- 1   // send value 1 on channel ch
	x = <-ch  // receive a value from channel ch (and assign to x)

Channel operations synchronize the communicating goroutines.

* Communicating goroutines

Each goroutine sends its results via channel ch:

.code src/concurrency2.go /f START/,/f END/

The main goroutine receives (and prints) all results from the same channel:

.play src/concurrency2.go /main START/,/main END/
